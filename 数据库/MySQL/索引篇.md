#### 什么是索引
**书中的目录**就是充当**索引**的角色，即**索引**是**数据的目录**。
#### 索引的分类

##### 数据结构分类
![](../../img/Pasted%20image%2020240329094226.png)
创建的主键索引和二级索引**默认**使用的是**B+树索引**。
B+树索引，**数据**都放在**叶子节点**，**索引**都在**非叶子节点**
B+树**比**B树**好**的点：
- 数据都存在叶子节点里，所以非叶子节点可以存更多的索引，这样同样的数据量，B+树比B树更加矮胖（I/0次数更小，每查一个节点，都是一次I/O操作）
- B+树的数据都是存在叶子节点中的，而叶子节点是由双链表连起来的，查找数据的时候比B树效率更高
**注意**：**叶子节点**之间应该是**双向链表**。
![](../../img/Pasted%20image%2020240329094350.png)
##### 物理存储分类
- **主键索引（聚簇索引）**： B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；
- **二级索引（非聚簇索引）**：B+Tree 的叶子节点存放的是主键值，而不是实际数据。
##### 字段特性分类
- **主键索引**：主键索引就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。
- **唯一索引**：唯一索引建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。
- **普通索引**：普通索引就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。
- **前缀索引**：前缀索引是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。
**前缀索引例子**：
假设我们有一个数据库表`users`，其中有一个`VARCHAR`类型的列`email`，用于存储用户的电子邮件地址。电子邮件地址通常较长，并且在很多情况下，邮件地址的开头部分（即用户名）就足以区分不同的记录。如果我们想要优化根据电子邮件地址搜索用户的操作，但又不想为整个电子邮件地址建立完整的索引，我们可以考虑使用前缀索引。
``` sql
CREATE INDEX idx_email_prefix ON users (email(10));
```
在这个例子中，`CREATE INDEX`命令用于在`users`表的`email`列上创建一个索引，但是与通常的做法不同，我们通过在列名后面添加`(10)`来指定仅对电子邮件地址的前10个字符建立索引。这意味着数据库系统将只使用每个电子邮件地址的前10个字符来构建索引。

##### 字段个数分类
- 单列索引：建立在单列上的索引，例如主键索引
- 联合索引：建立在多列上的索引
使用**联合索引**时，存在**最左匹配原则**，即按照最左优先的方式进行索引的匹配。
如果创建了一个 `(a, b, c)` 联合索引，如果查询条件是以下这几种，就可以匹配上联合索引：
- where a=1；
- where a=1 and b=2 and c=3；
- where a=1 and b=2；
如果where子句中**没有关于a的判断条件**，那么联合索引会**失效**，因为`（a，b，c）`联合索引，先按a排序，在a相同的情况再按b排序，在b相同的情况再按c排序。所以，**b和c是全局无序，局部相对有序的。**
###### 联合索引范围查询
查询范围的字段可以用到联合索引，在**范围查询字段的后面的字段无法用到联合索引**
**示例**：
Q1: `select * from t_table where a > 1 and b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
**在符合 a > 1 条件的二级索引记录的范围里，b 字段的值是无序的**。
**Q1 这条查询语句只有 a 字段用到了联合索引进行索引查询，而 b 字段并没有使用到联合索引**。

Q2: `select * from t_table where a >= 1 and b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
虽然在符合 a>= 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，**但是对于符合 a = 1 的二级索引记录的范围里，b 字段的值是「有序」的**
**Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询**。

Q3: `SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b = 2`，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？
在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 >= and =<。因此 **Q3 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询**。

Q4: `SELECT * FROM t_user WHERE name like 'j%' and age = 22`，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？
 name字段可以在联合索引的 B+Tree 中进行索引查询，形成的扫描区间是 【'j','k' )。注意， j 是闭区间。
 **对于符合 name = j 的二级索引记录的范围里，age字段的值是「有序」的**
 **Q4 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询**。
 综上所示，**联合索引的最左匹配原则，在遇到范围查询（如 >、<）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 >=、<=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配，前面我也用了四个例子说明了**。

##### 索引下推
现在我们知道，对于联合索引（a, b），在执行 `select * from table where a > 1 and b = 2` 语句的时候，只有 a 字段能用到索引，那在联合索引的 B+Tree 找到第一个满足条件的主键值（ID 为 2）后，还需要判断其他条件是否满足（看 b 是否等于 2），那是在联合索引里判断？还是回主键索引去判断呢？
- 在 MySQL 5.6 之前，只能从 ID2 （主键值）开始一个个回表，到「主键索引」上找出数据行，再对比 b 字段值。
- 而 MySQL 5.6 引入的**索引下推优化**（index condition pushdown)， **可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数**。

#### 索引优化的方法
##### 前缀索引优化
前缀索引可以减小索引字段大小，可以增加一个索引页中存储的索引值，有效提高索引的查询速度。
局限性：
- order by无法使用前缀索引
- 无法把前缀索引用作覆盖索引
##### 覆盖索引优化
假设我们只需要查询商品的名称、价格，有什么方式可以避免回表呢？
我们可以**建立一个联合索引**，即「商品ID、名称、价格」作为一个联合索引。如果索引中存在这些数据，**查询将不会再次检索主键索引，从而避免回表**。
所以，使用覆盖索引的好处就是，不需要查询出包含整行记录的所有信息，也就减少了大量的 I/O 操作。
##### 主键索引最好是自增
##### 索引最好设置为NOT NULL
- 第一原因：索引列存在 NULL 就会导致优化器在做索引选择的时候更加复杂，更加难以优化，因为可为 NULL 的列会使索引、索引统计和值比较都更复杂，比如进行索引统计时，count 会省略值为NULL 的行。
- 第二个原因：NULL 值是一个没意义的值，但是它会占用物理空间，所以会带来的存储空间的问题，因为 InnoDB 存储记录的时候，如果表中存在允许为 NULL 的字段，那么行格式（后续加链接）中**至少会用 1 字节空间存储 NULL 值列表**，如下图的紫色部分：