#### 封锁粒度
有两种封锁粒度：**行级锁**和**表级锁**

尽量**只锁定需要修改的那部分数据**，而不是所有的资源。锁定的**数据量越少**，发生锁**争用的可能就越小**，系统的**并发程度就越高**。

加锁需要**消耗资源**，锁的各种操作（获取锁、释放锁以及检查锁状态）都会增加系统开销。因此**封锁粒度越小**，**系统开销越大**。

选择锁粒度时，需要在锁开销和并发程度之间做一个权衡。

#### 封锁类型
##### 读写锁
- 排他锁：X锁，写锁
- 共享锁：S锁，读锁
###### 两个规定：
- 一个事务对数据对象A加了X锁，就可以对A进行读取和更新。加锁期间其他事务不能对A加任何锁
- 一个事务对数据对象A加了S锁，可以对A进行读取操作，但是不能进行更新操作。加锁期间其他事务能对A加S锁，但是不能加X锁。
##### 意向锁
可以更容易地支持多粒度封锁
在存在行级锁和表级锁的情况下，事务T想要对表A加X锁，就需要先检查是否有其他事务对表A或者表A中的任意一行加了锁，就**需要对表A的每一行进行检查，很耗费时间**。

**意向锁**在原来的X/S锁之上引入了IX/IS，IX/IS 都是表锁，用来表示一个事务想要在表中的某个数据行上加上X锁或S锁。
###### 两个规定：
- 一个事务在活动某个数据行对象的S锁之前，必须先获得表的IS锁或者更强的锁。
- 一个事务在获得某个数据行对象的X锁之前，必须先获得表的IX锁。