#### 未提交读(Read UNCOMMITTED)
事务中的修改，即时没有提交，对其他事务也是可见的。

#### 提交读(READ COMMITED)
一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其他事务是不可见的。

#### 可重复读(REPEATABLE READ)
保证在同一个事务中多次读取同样数据的结果是一样的

#### 可串行化(SERIALIZABLE)
强制事务串行执行


| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :--: | :--: | :--: | :--: |
| 未提交读 | √ | √ | √ |
| 提交读 | × | √ | √ |
| 可重复读 | × | × | √ |
| 可串行化 | × | × | × |
 [并发一致性问题](并发一致性问题.md)
#### 隔离级别水平高低排序
![](../../img/Pasted%20image%2020240329152516.png)
针对不同的隔离级别，并发事务时可能发生的现象也会不同
![](../../img/Pasted%20image%2020240329152722.png)
即：
- 在 **读未提交**隔离级别下，可能发生脏读、不可重复读和幻读现象
- 在 **读提交**隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象
- 在 **可重复读**隔离级别下，可能发生幻读现象，但不可能脏读和不可重复读现象。
- 在 **串行化**隔离级别下，脏读、不可重复读和幻读现象都不可能发生
#### ReadView在MVCC里如何工作的
##### ReadView概念
![](../../img/Pasted%20image%2020240329161642.png)
ReadView的**四个重要字段**
- m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的**事务 id 列表**，注意是一个列表，**“活跃事务”指的就是，启动了但还没提交的事务**。
- min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 **id 最小的事务**，也就是 m_ids 的最小值。
- max_trx_id ：这个并不是 m_ids 的最大值，而是**创建 Read View 时当前数据库中应该给下一个事务的 id 值**，也就是全局事务中最大的事务 id 值 + 1；
- creator_trx_id ：指的是**创建该 Read View 的事务的事务 id**。
##### 聚簇索引记录中的两个隐藏列
假设在账户余额表插入一条小林余额为100万的记录
![](../../img/Pasted%20image%2020240329162011.png)
对于使用 **InnoDB 存储引擎**的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：
- **trx_id**：当一个事务对某条聚簇索引记录进行改动时，就**会把该事务的事务id记录在trx_id隐藏列里。**
- **roll_pointer**：每次对某条聚簇索引记录进行改动，都会把旧版本的记录写入到undo日志中，**这个隐藏列是个指针，指向每一个旧版本记录**，于是可以通过它找到修改前的记录。

**在创建 Read View 后**，我们可以将记录中的 trx_id 划分这三种情况：
![](../../img/Pasted%20image%2020240329162652.png)
一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：
- 如果记录的 trx_id 值小于 Read View 中的 `min_trx_id` 值，表示这个版本的记录是在创建 Read View **前**已经提交的事务生成的，所以该版本的记录对当前事务**可见**。
- 如果记录的 trx_id 值大于等于 Read View 中的 `max_trx_id` 值，表示这个版本的记录是在创建 Read View **后**才启动的事务生成的，所以该版本的记录对当前事务**不可见**。
- 如果记录的 trx_id 值在 Read View 的 `min_trx_id` 和 `max_trx_id` 之间，需要判断 trx_id 是否在 m_ids 列表中：
    - 如果记录的 trx_id **在** `m_ids` 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务**不可见**。
    - 如果记录的 trx_id **不在** `m_ids`列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务**可见**。

**这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。**

#### 可重复读是如何工作的
可重复读隔离级别是启动事务时生成一个ReadView，然后整个事务期间都在用ReadView（**不会被改变**）
小林coding：
https://www.xiaolincoding.com/mysql/transaction/mvcc.html#read-view-%E5%9C%A8-mvcc-%E9%87%8C%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84

#### 读提交是如何工作的
读提交隔离级别是**每次读取数据**时，都会生成一个**新的ReadView**
小林coding：
https://www.xiaolincoding.com/mysql/transaction/mvcc.html#%E8%AF%BB%E6%8F%90%E4%BA%A4%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84
