#### Redis数据类型以及使用场景分别是什么
Redis **五种数据类型**的应用场景：
- **String 类型**的应用场景：缓存对象、常规计数、分布式锁、共享 session 信息等。
- **List 类型**的应用场景：消息队列（但是有两个问题：1. 生产者需要自行实现全局唯一 ID；2. 不能以消费组形式消费数据）等。
- **Hash 类型**：缓存对象、购物车等。
- **Set 类型**：聚合计算（并集、交集、差集）场景，比如点赞、共同关注、抽奖活动等。
- **Zset 类型**：排序场景，比如排行榜、电话和姓名排序等。
Redis 后续版本又支持**四种数据类型**，它们的应用场景如下：
- **BitMap**（2.2 版新增）：二值状态统计的场景，比如签到、判断用户登陆状态、连续签到用户总数等；
- **HyperLogLog**（2.8 版新增）：海量数据基数统计的场景，比如百万级网页 UV 计数等；
- **GEO**（3.2 版新增）：存储地理位置信息的场景，比如滴滴叫车；
- **Stream**（5.0 版新增）：消息队列，相比于基于 List 类型实现的消息队列，有这两个特有的特性：自动生成全局唯一消息ID，支持以消费组形式消费数据。
#### 五种常见的Redis数据类型的实现
![](../../img/Pasted%20image%2020240513195740.png)
#### Redis为什么这么快
- Redis 的大部分操作**都在内存中完成**，并且采用了高效的数据结构，因此 Redis 瓶颈可能是机器的内存或者网络带宽，而并非 CPU，既然 CPU 不是瓶颈，那么自然就采用单线程的解决方案了；
- Redis 采用单线程模型可以**避免了多线程之间的竞争**，**省去了多线程切换带来的时间和性能上的开销**，而且也不会导致死锁问题。
- Redis 采用了 **I/O 多路复用机制**处理大量的客户端 Socket 请求。
##### Redis引入多线程
Redis 6.0 版本之后，Redis 在启动的时候，默认情况下会**额外创建 6 个线程**（_这里的线程数不包括主线程_）：
- Redis-server ： Redis的主线程，主要负责执行命令；
- bio_close_file、bio_aof_fsync、bio_lazy_free：三个后台线程，分别异步处理关闭文件任务、AOF刷盘任务、释放内存任务；
- io_thd_1、io_thd_2、io_thd_3：三个 I/O 线程，io-threads 默认是 4 ，所以会**启动 3个 I/O 多线程，用来分担 Redis 网络 I/O 的压力。**
**Redis多线程工作实例：**
1. **接收请求**： 当客户端发送请求到 Redis 服务器时，这些请求首先被主线程（监听线程）接收。这个主线程负责监听来自客户端的 TCP 连接。
2. **多线程读操作**： 一旦请求到达，主线程将这些请求的数据从网络 socket 中读取出来。在 Redis 6.0 中，这个读取操作可以被分配给多个 I/O 线程来执行。这些线程并行工作，可以同时处理来自不同客户端的数据读取，减少了主线程的负载和网络 I/O 的等待时间。
3. **命令解析与执行**： 虽然多个 I/O 线程可以同时进行读操作，但读取的数据（即具体的 Redis 命令）需要被送回到主线程进行解析和执行。Redis 的数据结构访问和命令执行仍然是单线程的，以保证数据的一致性和操作的原子性。
4. **多线程写操作**： 当命令执行完成后，执行结果需要被发送回客户端。主线程将这些响应结果分配给 I/O 线程，这些线程则并行地将响应数据写入各自处理的客户端连接的网络 socket 中。
5. **完成响应**： I/O 线程完成数据的写入后，客户端接收到来自 Redis 的响应，整个请求处理周期结束。
#### Redis如何内存优化（大key）未解决

##### 大key定义
大key并不是指key的值很大，而是**key对应的value很大。**

一般而言，下面这**两种情况被称为大 key：**
- String 类型的值大于 10 KB；
- Hash、List、Set、ZSet 类型的元素的个数超过 5000个；
##### 大key会造成的问题
- **客户端超时阻塞**。由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。
- **引发网络阻塞**。每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。
- **阻塞工作线程**。如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。
- **内存分布不均**。集群模型在 slot 分片均匀情况下，会出现数据和查询倾斜情况，部分有大 key 的 Redis 节点占用内存多，QPS 也会比较大。
##### 找到大key的方法
1. _**redis-cli --bigkeys 查找大key**_
2. _**使用 SCAN 命令查找大 key**_
3. _**使用 RdbTools 工具查找大 key**_
##### 如何删除大key
如果**一下子释放了大量内存，空闲内存块链表操作时间就会增加**，相应地就会**造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时**，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。

_**1、分批次删除**_
_**2、异步删除**_
这样 Redis 会将这个 key 放入到一个异步线程中进行删除，这样不会阻塞主线程。
