#### 主要进行GC的区域
- **新生代收集**（Minor GC / Young GC）：只对新生代进行垃圾收集
- **老年代收集**（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是Major GC在有的语境中也用于指代整堆收集。
- **混合收集**（Mixed GC）：对整个新时代和部分老年代进行垃圾收集。
整堆收集 (Full GC)：收集整个 Java 堆和方法区。

#### 空间分配担保
空间分配担保是为了确保在Minor GC之前老年代本身还有容纳新生代所有对象的剩余空间。

#### 死亡对象判断方法
堆中几乎放着所有的对象实例，对堆垃圾回收之前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）

##### 引用计数法
给对象中添加一个引用计数器：
- 每当有一个地方引用它，计数器就加1
- 当引用失败，计数器就减1
- 任何时候计数器为0的对象就是不可能再被使用
这个方法实现简单，效率高，但是有一个**很大的问题**就是无法解决对象之间循环引用的问题。
**所谓对象之间的循环引用问题**：除了对象 `objA` 和 `objB` 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。

##### 可达性分析算法
这个算法的基本思想就是通过一系列的成为"**GC ROOTs**"的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到GC Roots 没有任何引用链相连的话，则证明对象是不可用的，需要被回收。
![](../../img/Pasted%20image%2020240220222434.png)
如图所示：O4-06之间虽然有引用关系，但是它们到GC Roots不可达，因此是需要被回收的对象。

**可以被作为GC Roots的对象**：
- 虚拟机栈（栈帧中的局部变量表）中引用的对象
- 本地方法栈中引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象
- 所有被同步锁持有的对象

**对象可以被回收，不代表一定会被回收**
- 当一个对象在可达性分析法中被标记为不可达时，它并不是立即被回收的，而是进入了一种"缓刑"状态。这意味着它处于即将被回收但尚未被回收的状态。
- 对于标记为不可达的对象，JVM会首先检查是否需要执行finalize方法。如果对象的类覆盖了finalize方法，且finalize方法从未被调用过，那么JVM会将这个对象标记为“需要执行finalize方法”，否则认为不需要执行finalize方法。
- 需要执行finalize方法的对象将被放入一个队列中，等待进行第二次标记。在第二次标记之前，如果对象与引用链上的任何一个对象重新建立关联，那么它将被视为仍然可达，不会被回收。否则，对象将会被真正地回收。

#### 引用类型总结
##### 强引用
使用最普遍的引用。如果一个对象具有强引用，垃圾回收器绝对不会回收它。
##### 软引用
如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。
##### 弱引用
垃圾回收器扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间是否足够，都会直接回收
##### 虚引用
虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

#### 垃圾收集算法

##### 标记-清除算法
标记-清除（Mark-and-Sweep）算法分为“标记（Mark）”和“清除（Sweep）”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。

它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来**两个明显的问题**：
1. **效率问题**：标记和清除两个过程效率都不高。
2. **空间问题**：标记清除后会产生大量不连续的内存碎片。
整个**标记-清除过程**大致是这样的：
1. 当一个对象被创建时，给一个标记位，假设为 0 (false)；
2. 在标记阶段，我们将所有可达对象（或用户可以引用的对象）的标记位设置为 1 (true)；
3. 扫描阶段清除的就是标记位为 0 (false)的对象。

##### 复制算法
复制算法的基本思想是将堆内存划分为两个大小相等的区域，通常称为From空间和To空间。在垃圾回收过程中，只使用其中的一个空间来分配对象，当该空间被填满时，就触发垃圾回收操作。
**过程**：
垃圾回收开始时，所有存活的对象都被复制到另一个空间，即To空间，而非存活的对象则被直接忽略。复制完成后，From空间中的所有对象都被视为垃圾，并可以被直接回收。之后，From空间和To空间的角色互换，To空间变为新的From空间，From空间变为空闲状态，用于下一轮垃圾回收。这样，垃圾回收过程就完成了一次从一半空间到另一半空间的复制。
存在以下**问题**：
- **可用内存变小**：可用内存直接缩减为原来的一半。
- **不适合老年代**：如果存活对象数量比较大，复制性能会变得很差。
##### 标记-整理算法
和标记-清除算法差不多，就是最后多了一步整理阶段，解决内存碎片问题，对存活对象进行压缩，使它们连续存放在一起，从而产生一个大的连续的内存块。

##### 分代收集算法
当前虚拟机的垃圾收集都采用分代收集算法，只是根据对象存活周期的不同将内存分为几块。一般将 Java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。
**比如**在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。