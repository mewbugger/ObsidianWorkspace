#### 运行时数据区

![](../../img/Pasted%20image%2020240513123852.png)
##### 字符串常量池
字符串常量池是JVM为了提升性能和减少内存消耗针对字符串（String类）专门开辟的一块区域，主要目的是为了字符串的重复创建。
示例如下：
``` java
// 在堆中创建字符串对象”ab“
// 将字符串对象”ab“的引用保存在字符串常量池中
String aa = "ab";
// 直接返回字符串常量池中字符串对象”ab“的引用
String bb = "ab";
System.out.println(aa==bb);// true

```
**JDK1.7之后**字符串常量池和静态变量从永久代（方法区）移动到Java堆中。**JDK1.8之后**，永久代被替换为元空间（方法区）。

##### 堆
###### 内存划分
Java堆事Java虚拟机管理的内存中最大的一块，被所有线程共享。此内存区域的**唯一目的就是存放对象实例**，几乎所有的对象实例以及数据都在这里分配内存。

虚拟机把对内存逻辑上分为三块区域，这样做的**唯一目的**是为了**优化垃圾回收性能**：
![](../../img/Pasted%20image%2020240218171551.png)

1. **新生代**：新对象和没达到一定年龄的对象都在新生代
新生代是所有新对象创建的地方。当填充新生代的时候，执行垃圾回收，这种垃圾回收被称为`Minor GC`。新生代被分为三个部分（一个伊甸园和两个幸存区，默认比例式8：1：1）
- 大多数新创建的对象都在伊甸园内存空间中。
- 当伊甸园空间被对象填充时，执行`Minor GC`，并将所有幸存者对象转移到一个幸存者内存空间中。
- `Minor GC`检查幸存者对象，并将它们移动到另一个幸存者空间。所以每次，一个幸存者空间总是空的。
-  经过多次 `GC` 循环后存活下来的对象被移动到老年代。通常，这是通过设置年轻一代对象的年龄阈值来实现的，然后他们才有资格提升到老一代
2. **老年代**：被长时间使用的对象，老年代的内存空间应该要比新生代更大
老年代内存包含那些经过许多轮小型GC后仍然存活的对象。通常，垃圾收集是在老年代内存满时执行的。老年代垃圾回收称为主GC（`Major GC`），通常需要更长的时间。
**大对象**（大对象是指需要大量连续内存空间的对象）**直接进入老年代**。这样做的目的是**避免在伊甸园和两个幸存区之间发生大量的内存拷贝**。
3. **元空间（1.8之前叫做永久代）**：像一些方法中的操作临时对象等，1.8之前是占用JVM内存，JDK1.8之后直接使用物理内存。
不管是 JDK8 之前的永久代，还是 JDK8 及以后的元空间，都可以看作是 Java 虚拟机规范中**方法区的实现**（[方法区](内存区域.md#方法区)）。
虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫 `Non-Heap`（非堆），目的应该是与 Java 堆区分开。

###### 对象在堆中的生命周期
1. 在JVM内存模型的堆中，堆被划分为新生代和老年代
- 新生代被进一步划分为`Eden`和`Survivor`，`Survivor`由`From Survivor`和`To Survivor`组成
2. 当创建一个对象时，对象会被优先分配到新生代的Eden
- 此时JVM会给对象定义一个**对象年轻计数器**（`-XX:MaxTenuringThreshold`）
3. 当`Eden`空间不足时，JVM将执行新生代的垃圾回收（`Minor GC`）
- JVM会把存活的对象转移到`Survivo`r中，并且对象年龄+1
- 对象在`Survivor`中同样也会经历`Minor GC`，每经历一次Minor GC，对象年龄都会+1
4. 如果分配的对象超过了`-XX:PetenureSizeThreshold`，对象会被**直接分配到老年代**。
###### 对象的分配过程
1. new的对象先放在伊甸园，伊甸园有大小限制。
2. 伊甸园空间满的时候，程序又需要创建对象，JVM的垃圾回收器会对伊甸园进行垃圾回收（`Minor GC`），将伊甸园区中的不再被其他对象所引用的对象进行销毁。再加载新的对象放到伊甸园。
3. 然后将伊甸园中的剩余对象移动到幸存0区。
4. 如果再次触发垃圾回收，此时上次幸存下来的放到幸存0区，如果没有回收，就会放到幸存1区。
5. 如果再次经历垃圾回收，此时会重新放回幸存0区，接着再去幸存1区，如此循环，所以总有一个幸存区是空着。
6. 默认是15次回收标记的时候去老年代。
7. 老年代中，相对悠闲。当老年代内存不足，再次触发`Major GC`，进行老年代的内存清理。
8. 如果老年代执行了Major GC之后发现依然无法进行对象的保存，就会产生OOM异常。

##### 方法区（JDK1.8里的元空间）

##### 程序计数器
是一块较小的内存空间，可以看作是当前线程所执行的字节码的**行号指示器**。

字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令。它是程序控制流的**指示器**，**分支、循环、跳转、异常处理、线程恢复**等基础功能都需要依赖这个计数器来完成。

Java虚拟机的多线程是通过线程轮流切换、分配处理器执行时间的方式来实现的，在任何一个时候，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。
**因此**，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器**互不影响，独立存储**，称这类内存区域为**线程私有**的内存。

如果下线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟字节码指令的地址；如果正在执行的是本地（Native）方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个**没有规定**任何`OutOfMemoryError`情况的区域。

##### 虚拟机栈
![](../../img/Pasted%20image%2020240513125118.png)
Java虚拟机栈也是**线程私有**的，它的生命周期与线程相同。

**虚拟机栈描述**的是Java方法执行的**线程内存模型**：每个**方法被执行**的时候，Java虚拟机都会**同步创建**一个**栈帧**（用于存储局部变量表，操作数栈，动态连接，方法出口等信息）。
每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。

**局部变量表**存放了编译器可知的各种Java虚拟机基本数据类型、对象引用类型（不等同于对象本身，**可能是**一个指向对象起始地址的引用指针，**也可能是**指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。

这些数据类型在局部变量表中的存储空间以**局部变量槽（slot）** 来表示，其中64位长度的**long和double**类型的数据会占用**两个变量槽**，其余数据类型只会占用一个。

局部变量表的**内存空间**在**编译期间**完成分配，当进入一个方法时，这个方法在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的**大小**（这里的大小指的是slot的数量）。

虚拟机栈中规定了**两类异常状况**：
- `StackOverFlowError`：如果线程请求的栈深度大于虚拟机所允许的深度，会抛出。
- `OutOfMemoryError`：如果虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出。
