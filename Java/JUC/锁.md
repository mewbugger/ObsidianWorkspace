#### 乐观锁 VS 悲观锁
线程是否锁住同步资源：
- **锁住**：乐观锁
- **不锁住**：悲观锁
**悲观锁**：认为自己在使用数据的时候一定有别的现场来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
**乐观锁**：认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据，如果这个数据没有被更新，当前线程将自己修改的数据成功写。（[CAS](原子类.md#CAS)）

**悲观锁适合写操作多的场景**，先加锁可以保证写操作时数据正确。
**乐观锁适合读操作多的场景**，不加锁的特点能够使其读操作的性能大幅提升。
#### 自旋锁 VS 适应性自旋锁
同步资源加锁失败，线程是否阻塞：
**阻塞**：互斥锁
**不阻塞**：自旋锁，适应性自旋锁
阻塞或唤醒一个Java线程需要操作系统切换CPU状态来完成，这种状态转换需要耗费处理器时间。**如果同步代码块中的内容过于简单，状态转换消耗的时间有可能比用户代码执行的时间还要长**。
在很多场景中（**例如增加计数器counter**），同步资源的锁定时间是很短的，**为了这一小段时间去切换线程，线程挂起和恢复现场的花费可能让系统得不偿失。**
那么遇到这种情况的时候，让线程**暂时等待一下（自旋）**，如果自旋完成后，之前需要锁住同步资源的线程释放了锁，那么**当前线程就可以不必阻塞而直接获得同步资源**。
**自旋锁的缺点**：自旋虽然可以避免线程切换的开销，但是要占用处理器时间，如果锁被占用的时间很短，那么效果很好。**反之，如果锁被占用的时间很长，自旋的线程会一直占用处理器而不作用，浪费处理器资源。**
自旋原理同样是[CAS](原子类.md#CAS)
#### 无锁 VS 偏向锁 VS 轻量级锁 VS 重量级锁
**这四种锁是指锁的状态，专门针对synchronized的**
多个线程竞争同步资源的流程细节的区别：
**无锁**：不锁住资源，多个线程中只有一个能修改资源成功，其他线程会重试
**偏向锁**：同一个线程执行同步资源时自动获取资源
**轻量级锁**：多个线程竞争同步资源时，没有获 取资源的线程自旋等待锁释放
**重量级锁**：多个线程竞争同步资源时，没有获取资源的线程阻塞等待唤醒。
#### 公平锁 VS 非公平锁
多个线程竞争锁时是否排队：
**排队**：公平锁
**先尝试插队，插队失败再排队**：非公平锁
**公平锁**适用于需要严格按照顺序处理任务或资源的场景（**任务调度，消息队列，资源分配**），而**非公平锁**适用于对性能要求较高、任务处理时间较短、且任务处理顺序不那么敏感的场景（**缓存系统，线程池**）。
#### 可重入锁 VS 非可重入锁
一个线程中的多个流程能否获取同一把锁
**能**：可重入锁
**不能**：非可重入锁
可重入锁，指一个线程在外层方法获取锁的时候，再进入该线程的内存方法会自动获取锁（**前提是锁对象得是同一个对象或class**），不会因为之前已经获取过锁还没释放而阻塞。Java中ReentrantLock和synchronized都是可重入锁。
可重入锁示例如下：
``` java
public class Widget {
    public synchronized void doSomething() {
        System.out.println("方法1执行...");
        doOthers();
    }
    public synchronized void doOthers() {
        System.out.println("方法2执行...");
    }
}

如果是不可重入锁，那么这段代码就会发生死锁。
doSomething需要等doOthers执行完才释放锁，而doOthers需要获取锁才能执行。
```
可重入锁的底层原理是AQS
#### 共享锁 VS 排他锁
多个线程能否共享一把锁
**能**：共享锁
**不能**：排他锁
**独享锁也叫排他锁**，是指该锁一次只能被一个线程所持有。如果线程T对数据A加上排它锁后，则其他线程不能再对A加任何类型的锁。获得排它锁的线程即能读数据又能修改数据。JDK中的synchronized和JUC中Lock的实现类就是互斥锁。
**共享锁**是指该锁可被多个线程所持有。如果线程T对数据A加上共享锁后，则其他线程只能对A再加共享锁，不能加排它锁。获得共享锁的线程只能读数据，不能修改数据。
独享锁与共享锁也是通过[AQS](AQS.md)来实现的，通过实现不同的方法，来实现独享或者共享。