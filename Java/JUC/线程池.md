#### 线程池的概念
是一种基于池化思想管理线程的工具，经常出现在多线程服务器中，如MySQL。
**使用线程池带来的一系列好处：**
- **降低资源消耗**：通过池化技术重复利用已创建的线程，降低线程创建和销毁造成的损耗。
- **提高响应速度**：任务到达时，无需等待线程创建即可立即执行。
- **提高线程的可管理性**：线程是稀缺资源，如果无限制创建，不仅会消耗系统资源，还会因为线程的不合理分布导致资源调度失衡，降低系统的稳定性。使用线程池可以进行统一的分配、调优和监控。
- **提供更多更强大的功能**：线程池具备可拓展性，允许开发人员向其中增加更多的功能。比如延时定时线程池ScheduledThreadPoolExecutor，就允许任务延期执行或定期执行。
#### 线程池解决的问题
**在并发环境下，系统不能够确定**在任意时刻中，**有多少任务需要执行，有多少资源需要投入**。这种不确定性将带来**以下若干问题**：
1. 频繁申请/销毁资源和调度资源，将带来额外的消耗，可能会非常巨大。
2. 对资源无限申请缺少抑制手段，易引发系统资源耗尽的风险。
3. 系统无法合理管理内部的资源分布，会降低系统的稳定性。
#### 线程池如何维护自身状态
有五种运行状态：
![](../../img/Pasted%20image%2020240514011355.png)
生命周期转换如下：
![](../../img/Pasted%20image%2020240514011421.png)
#### 任务执行机制
##### 任务调度
![](../../img/Pasted%20image%2020240514011526.png)
##### 任务缓冲
任务缓冲模块是线程池能够管理任务的核心部分。线程池的本质是对任务和线程的管理，而做到这一点最关键的思想就是将**任务和线程两者解耦**，不让两者直接关联，才可以做后续的分配工作。线程池中是**以生产者消费者模式，通过一个阻塞队列来实现的。阻塞队列缓存任务，工作线程从阻塞队列中获取任务。**

阻塞队列(BlockingQueue)是一个支持两个附加操作的队列。这两个附加的操作是：**在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。** 阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。

下图中展示了线程1往阻塞队列中添加元素，而线程2从阻塞队列中移除元素：![](../../img/Pasted%20image%2020240514011640.png)
##### 任务申请
![](../../img/Pasted%20image%2020240514011834.png)
##### 任务拒绝
任务拒绝模块是线程池的保护部分，线程池有一个最大的容量，**当线程池的任务缓存队列已满，并且线程池中的线程数目达到maximumPoolSize时，就需要拒绝掉该任务，采取任务拒绝策略，保护线程池。**
![](../../img/Pasted%20image%2020240514011914.png)
#### 核心参数
##### corePoolSize：核心线程数
线程池维护的最小线程数量，核心线程创建后不会被回收（注意：设置allowCoreThreadTimeout=true后，空闲的核心线程超过存活时间也会被回收）。

大于核心线程数的线程，在空闲时间超过keepAliveTime后会被回收。
线程池刚创建时，里面没有一个线程，当调用 execute() 方法添加一个任务时，如果正在运行的线程数量小于corePoolSize，则马上创建新线程并运行这个任务。
##### maximumPoolSize：最大线程数
线程池允许创建的最大线程数量。
当添加一个任务时，核心线程数已满，线程池还没达到最大线程数，并且没有空闲线程，工作队列已满的情况下，创建一个新线程并执行。
##### keepAliveTime：空闲线程存活时间
当一个可被回收的线程的空闲时间大于keepAliveTime，就会被回收。
可被回收的线程：
设置allowCoreThreadTimeout=true的核心线程。
大于核心线程数的线程（非核心线程）。
##### unit：时间单位
##### workQueue：工作队列
##### threadFactory：线程工厂

#### 线程池在业务中的实践
##### 快速响应用户请求

**描述：** 用户发起的**实时请求，服务响应时间**。比如用户要查看一个商品的信息，那么我们**需要将商品维度的一系列信息**如商品的价格、优惠、库存、图片等等**聚合起来，展示给用户**。

**分析**：从用户体验角度看，这个结果响应越快越好，如果一个页面半天都刷不出来，用户可能就放弃查看这个商品了。而用户的功能聚合通常非常复杂，伴随着调用与调用之间的级联、多级级联等情况，业务开发同学往往会选择使用线程这种简单的方式，将**调用封装成任务并行地执行，缩短总体响应时间。** 另外，使用线程池也是有考量的，这种场景最重要的就是**获取最大响应速度去满足用户**，所以应该**不设置队列去缓存并发任务**，**调高corePoolSize和maxPoolSize去尽可能创造多的线程快速执行任务**。
![](../../img/Pasted%20image%2020240514095359.png)
##### 快速处理批量任务

**描述**：**离线的大量计算任务，需要快速执行**。比如说，统计某个报表，需要计算出全国各个门店中有哪些商品有某种属性，用于后续营销策略的分析，那么我们需要查询全国所有门店中的所有商品，并且记录具有某属性的商品，然后快速生成报表。

**分析**：这种场景**需要执行大量的任务，也希望任务执行越快越好**，这种情况下，也应该使用多线程策略，并行计算。但与响应速度优先的场景区别在于，**这类场景任务量巨大，并不需要瞬时完成，而是关注如何使用有限的资源，尽可能在单位时间内处理更多的任务，也就是吞吐量的问题**。所以**应该设置队列去缓冲并发任务**，调整合适的corePoolSize去设置处理任务的线程数。在这里，设置的线程过多可能还会引发线程上下文切换频繁的问题，也会降低处理任务的速度，降低吞吐量。
![](../../img/Pasted%20image%2020240514102455.png)

**改用线程池和任务队列的优势：**
1. **避免资源耗尽**：使用10个核心线程和一个任务队列，避免一次性创建1000个线程，减少资源消耗。
2. **减少上下文切换**：线程池通过复用固定数量的线程，减少上下文切换的开销，提高处理效率。
3. **平衡任务处理**：队列可以缓冲大量任务，使得高峰期的任务流量平稳化，线程池逐步处理任务，保证系统稳定性。
4. **提高吞吐量**：合适的线程池大小和任务队列能够在单位时间内处理更多任务，实现资源的高效利用和吞吐量的最大化。
