#### 如何保证消息正确地发送至RabbitMQ？如何确保消息接收方消费了消息
- **消息确认机制：** 生产者在发送消息后，可以通过消息确认机制（Confirm）确保消息被正确地发送至RabbitMQ。消息确认机制分为批量确认和单个确认两种方式，生产者可以选择适合自己业务场景的确认方式。
- **消息持久化：** 通过将消息设置为持久化的方式，可以确保消息在发送至 RabbitMQ 后即使 RabbitMQ 崩溃或者重启，消息仍然可以得到保留。在发送消息时，**可以将消息的 delivery mode 设置为 2，表示消息需要被持久化。**
- **连接超时设置：** 在发送消息时，可以设置连接超时时间，当超过指定时间后仍未能成功发送消息时，可以通过**重试等方式确保消息正确地发送至RabbitMQ。**
- **消息序列化和反序列化：** 在发送和接收消息时，需要将消息对象序列化为二进制数据，再在接收方反序列化为消息对象。因此，需要确保消息对象的序列化和反序列化过程正确无误，可以采用 JSON、Protobuf 等常用的序列化和反序列化工具。
#### 如何避免消息重复投递或重复消费
- **消息确认机制：** 在消费者处理消息后，通过发送消息确认（ACK）给 RabbitMQ，告知消息已被正确处理。如果消费者没有发送确认消息，RabbitMQ 会将消息重新投递到队列中，导致重复消费。
- **消息去重机制：** 可以在应用程序中实现一个消息去重的机制，例如**使用分布式缓存、数据库等存储系统，记录已经处理过的消息标识，以便下次处理时进行判断**。如果消息已经被处理过，则可以直接忽略，避免重复处理。
- **消息幂等性处理：** 可以将消费者的处理逻辑设计为幂等操作，即**重复执行多次仍然具有相同的效果**，避免因为消息重复消费导致业务数据错误。
- **设置消息过期时间：** 可以在消息发送时设置过期时间，在**消息过期后不再投递给消费者，避免重复消费。**
- **使用消息唯一标识符：** 可以在消息中添加唯一标识符，例如 UUID，保证每个消息都有独一无二的标识符，避免重复消费和重复投递。
#### 如何保证消息持久化
- **将消息的 delivery mode 设置为 2：** 在发送消息时，可以将消息的 delivery mode 属性设置为 2，表示消息需要被持久化。**持久化的消息将会被写入磁盘**，即使 RabbitMQ 重启或者崩溃，消息仍然可以得到保留。
- **将队列的 durable 属性设置为 true：** 在创建队列时，可以将队列的 durable 属性设置为 true，**表示队列是持久化的**。持久化的队列将会在 RabbitMQ 重启或者崩溃后得到保留。
- **将交换器的 durable 属性设置为 true：** 在创建交换器时，可以将交换器的 durable 属性设置为 true，表示**交换器是持久化**的。持久化的交换器将会在 RabbitMQ 重启或者崩溃后得到保留。
- **使用事务机制：** 在发送消息时，可以使用事务机制来确保消息的持久化。通过开启事务，发送者可以将消息发送到 RabbitMQ，然后**等待 RabbitMQ 的确认，确认后再提交事务。使用事务机制可以确保消息的可靠性**，但是会影响系统的性能
#### 消息如何路由
- 生产者将消息发送到指定的交换器中。
- 交换器根据路由键（Routing Key）和绑定键（Binding Key）将消息发送到一个或多个队列中。路由键和绑定键可以是任意字符串，根据交换器的类型和绑定规则进行匹配。
- 如果交换器类型为 `direct`，会根据路由键进行**精确匹配**，将消息发送到**所有匹配的队列**中。
- 如果交换器类型为 `fanout`，会将消息发送到**所有绑定到该交换器的队列**中。
- 如果交换器类型为 `topic`，会**根据通配符匹配规则将消息发送到匹配的队列**中。例如，路由键为 "foo.bar" 的消息可以匹配绑定键为 "*.bar" 或 "foo.#" 的队列。
- 如果交换器类型为 `headers`，会**根据消息的属性（headers）进行匹配**，将消息发送到匹配的队列中。
- 如果**没有匹配的队列，消息将被丢弃或返回给生产者，根据生产者的配置**。
需要注意的是，交换器和队列都需要进行绑定，否则消息将无法路由到队列中。另外，可以根据需要在交换器和队列中配置各种属性，例如持久化、自动删除等，以满足不同的业务需求。
#### RabbitMQ的消息确认过程
- 消费者从 RabbitMQ 中获取消息，处理消息。
- 处理完成后，向 RabbitMQ 发送确认消息（ACK）。确认消息通常是一个简单的 AMQP 基本确认帧，带有消息的标识符（delivery tag）和是否批量确认的标记。
- RabbitMQ 收到确认消息后，将该消息从队列中删除。
- 如果消费者在一定时间内没有发送确认消息，RabbitMQ 将认为消息未被正确处理，将会重新将消息投递到队列中，等待下一次消费。
在某些情况下，消费者可能无法正确处理消息，例如消费者崩溃或出现异常等。为避免这种情况导致消息丢失，**RabbitMQ 还提供了 Nack（Negative Acknowledge）和 Reject 机制**，可以将消息标记为无法处理或无法路由的状态，使其重新回到队列中等待下一次投递。
可以通过**设置重试次数和重试时间间隔等参数**，进行**消息重试和延迟投递的配置**，以满足不同的业务需求。
#### 消息基于什么传输
RabbitMQ 使用信道的方式来传输数据。信道是建立在真实的 TCP 连接内的虚拟连接，且每条 TCP 连接上的信道数量没有限制。
#### 如何保证高可用的？RabbitMQ的集群？
**普通集群模式**：普通集群模式是 RabbitMQ 最常见的集群模式，也是最简单的一种模式。在普通集群模式下，多台 RabbitMQ 服务器通过网络连接组成一个集群，共同管理消息队列，并通过节点之间的通信进行消息的传递和路由。普通集群模式适用于大多数应用场景，提供了高可用性和可靠性。

**镜像集群模式**：镜像集群模式是一种高可用性的集群模式，可以提高 RabbitMQ 集群的可靠性和容错能力。在镜像集群模式下，每个节点都有多个镜像节点，镜像节点会自动复制主节点的消息队列，并在主节点出现故障时接管消息队列的处理。镜像集群模式适用于对消息可靠性要求较高的场景，但是会增加网络带宽和存储成本。

**Federated集群模式**：Federated 集群模式是 RabbitMQ 的一种特殊的集群模式，可以将多个 RabbitMQ 集群组成一个逻辑上的整体，并通过 Federation 插件实现集群之间的消息传递和路由。Federated 集群模式适用于需要跨多个数据中心或地理位置分布的场景，但是会增加网络延迟和复杂度。
#### 死信队列和延迟队列的使用
死信队列：当消息无法被正确处理时，可以将该消息转发到死信队列中，以便进行进一步的处理。通过使用死信队列，可以将无法处理的消息统一存储和管理，并通过设置合适的 TTL 和 DLX 等参数，灵活控制消息的转发和重新处理。
使用死信队列的主要步骤如下：
- 创建一个普通队列和一个死信交换器；
- 将普通队列绑定到死信交换器，并指定死信队列的路由键；
- 在发送消息时，可以将消息的 TTL 设置为一个较小的值，当消息未被消费者处理时，该消息会被转发到死信队列中。
延迟队列：当需要在一定时间后才能处理某个消息时，可以使用延迟队列。通过设置消息的 TTL 和 DLX 等参数，可以将消息转发到一个指定的队列中，以便在一定的时间后再进行处理。使用延迟队列可以灵活地控制消息的发送和处理时间，适用于很多场景，如订单超时处理、提醒任务等。
使用延迟队列的主要步骤如下：
- 创建一个普通队列和一个交换器；
- 在交换器中设置消息的 TTL 和 DLX 等参数，将消息转发到指定的队列中；
- 在指定的队列中处理消息。
#### 如何保证消息的顺序性
一个队列只有一个消费者的情况下才能保证顺序，否则只能通过全局ID实现（**每条消息都一个msgld，关联的消息拥有一个parentMsgld。可以在消费端实现前一条消息未消费，不处理下一条消息；也可以在生产端实现前一条消息未处理完不发下一条信息。**）
#### 无法被路由的消息去了哪里
mandatory: true返回消息给生产者。
mandatory: false 直接丟弃。
#### 消息什么时候会变成死信
消息拒绝并且没有设置重新入队；消息过期；消息堆积，并且队列达到最大长度，先入队的消息会变成DL。
#### RabbitMQ事务机制
RabbitMQ 支持事务机制，用于在发送消息时保证事务的原子性。事务机制允许在多个 RabbitMQ 操作中声明事务，并在最终确认消息被完全处理之前，将多个操作打包为一个原子操作。
在 RabbitMQ 中，事务机制的使用流程如下：
- 开启事务：在发送消息之前，使用 txSelect 方法开启事务；
- 发送消息：使用 basicPublish 方法发送消息；
- 提交事务：使用 txCommit 方法提交事务，如果提交成功，则消息会被 RabbitMQ 确认，否则消息会被回滚；
- 回滚事务：使用 txRollback 方法回滚事务，如果回滚成功，则之前发送的消息会被撤销，否则消息会被继续处理。

需要注意的是，使用事务机制会对 RabbitMQ 的性能产生一定的影响，因此建议在必要的情况下使用，例如在消息的可靠性要求非常高的场景下。在消息量较大的场景下，可以使用事务机制的替代方案，如消息确认机制（ACK机制）等，以保证系统的高性能和可靠性