#### RocketMQ的事务消息是如何实现的
RocketMq的事务消息是通过TransactionListener接口来实现的
![](../../img/Pasted%20image%2020240601211008.png)
拆解下来的话，主要有以下4个步骤：
1. **发送半消息**：应用程序和RocketMQ Broker发送一条**半消息（将被存储在Broker端的事务消息日志中，但是这个消息还不能被消费者消费。）**，该消息在Broker端的事务消息日志中被标记为“**prepared**”状态。
2. **执行本地事务**：RocketMQ会通知应用程序执行本地事务。如果本地事务执行成功，应用程序通知RocketMQBroker提交该事务消息。
3. **提交事务消息**：RocketMQ收到提交消息以后，会将消息的状态从“prepared”改为“committed”，并使该消息可以被消费者消费。
4. **回滚事务消息**：如果本地事务执行失败，应用程序通知RocketMQ Broker回滚该事务消息，RocketMQ将该消息的状态从“prepared”改为“rollback”，并将该消息从事务消息日志中删除，从而保证该消息不会被消费者消费。
##### 如果一直没收到COMMIT或者ROLLBACK怎么办
在RocketMQ的事务消息中，如果**半消息发送成功后**，RocketMQ Broker在规**定时间内没有收到COMMIT或者ROLLBACK消息。**

RocketMQ会**向应用程序发送一条检查请求**，应用程序可以通过回调方法返回是否要提交或回滚该事务消息。如果应用程序在规定时间内未能返回响应，RocketMQ会将消息标记为“**UNKNOW**”状态。
在标记为“**UNKNOW**”状态的事务消息中，如果应用程序有了明确的结果，还可以向MQ发送COMMIT或者ROLLBACK。 

但是MQ不会一直等下去，如果过期时间已到，RocketMQ会自动回滚该事务消息，将其从事务消息日志中删除。
##### 为什么要用事务消息
本地事务完成之后再发送消息**可能会发送消息失败**。一旦发送消息失败，那么本地事务提交了，但是消息没成功，那么监听者就收不到消息，那么就**产生数据不一致**。

如果使用事务消息。先提交一个半消息，然后执行本地事务，再发送一个commit的半消息。如果后面这个commit消息失败了，**MQ是可以基于第一个半消息不断反查来推进状态。这样只要本地事务提交成功，最终MQ也会成功。如果本地事务rollback，那么MQ的消息也会rollback，保证了一致性。****


#### RocketMQ如何保证消息不丢失
1. **消息存储机制**：
	- **同步刷盘**: RocketMQ 支持同步刷盘机制（Synchronous Flush）。当消息写入到存储文件后，会立即同步写入磁盘。这种方式保证了在 Broker 异常宕机时，已经写入的消息不会丢失。
2. **消息复制**：
	- **多副本存储**: RocketMQ 支持主从复制（Master-Slave Replication）。消息写入到主节点后，会同步或异步复制到从节点。即使主节点发生故障，从节点也可以继续提供消息读取服务，保证消息不丢失。
3. **高可用架构**：
	- **Broker 集群**: 通过部署 Broker 集群，RocketMQ 提供高可用性和容灾能力。在某个 Broker 宕机时，其他 Broker 可以继续处理消息，保证服务不中断。
	- **NameServer 集群**: NameServer 负责存储和管理所有 Broker 的路由信息，并为客户端提供查询服务。通过部署 NameServer 集群，可以提高路由服务的可用性。
4. **消息确认机制**：
	- **生产者确认**: 生产者在发送消息后，会等待 Broker 的确认响应（ACK），只有在收到确认后，生产者才认为消息发送成功。这种机制确保了消息在发送过程中的可靠传输。
	- **消费者确认**: 消费者在成功处理消息后，会向 Broker 发送确认（ACK）。只有在收到确认后，Broker 才会将消息标记为已消费。这种机制保证了消息不会因为消费失败而丢失。
5. **消息重试和补偿**：
	- **消息重试**: 在消息发送或消费失败时，RocketMQ 支持自动重试机制。生产者可以配置重试策略，在消息发送失败时进行多次重试。消费者在消费失败时，也可以通过配置重试策略重新消费消息。
	- **死信队列（DLQ）**: 如果消息经过多次重试仍然消费失败，RocketMQ 会将消息发送到死信队列。这样可以避免消息丢失，并且提供了后续手动处理和分析的机会。

##### RocketMQ如何实现延时消息
当消息发送到Broker后，Broker会将消息根据延迟级别进行存储。**RocketMQ的延迟消息实现方式是：将消息先存储在内存中，然后使用Timer定时器进行消息的延迟，到达指定的时间后再存储到磁盘中，最后投递给消费者。**

RocketM5.0中新增了基于时间轮实现的定时消息：**基于时间轮的定时消息。时间轮是一种高效的定时器算法，能够处理大量的定时任务，并且能够在O(1)时间内找到下一个即将要执行的任务，因此能够提高消息的投的性能。****

**基于时间轮的定时消息具体实现方式如下：**
1. RocketMQ在Broker端使用一个时间轮来管理定时消息，将消息按照过期时间放置在不同的槽位中，这样可以大幅减少定时器任务的数量。
2. 时间轮的每个槽位对应一个时间间隔，比如 1秒、5秒、10秒等，每次时间轮的滴答，槽位向前移动一个时间间隔。
3. 当Broker接收到定时消息时，根据消息的过期时间计算出需要投递的槽位，并将消息放置到对应的槽位中。
4. 当时间轮的滴答到达消息的过期时间时，时间轮会将该槽位中的所有消息投递给消费者。
#### RocketMQ消息堆积如何解决
堆积原因一般是客户端本地消费过程中，**由于消费耗时过长或者消费并发度较小等原因，导致客户端消费能力不足，出现消息堆积地问题。**
**解决方案**：
1. **增加消费者数量**：消息堆积了，消费不过来，那就把消费者数量增加一下，让更多的实例来消费这些消息。
2. **提升消费者消费速度**：比如引入线程池、本地消息存储后即返回成功后续再慢慢消费等。
3. **降低生产者的生产速度**：如果生产者可控的话，可以让生产者生成消息的速度慢一点。
4. **清理过期消息**：有一些过期消息、或者一直无法成功的消息，在业务做评估之后，如果无影响或则影响不大，其实是可以清理的。
5. **调整RocketMQ的配置参数**：例如消息消费模式、消息拉取间隔时间等
6. **增加Topic队列数**：